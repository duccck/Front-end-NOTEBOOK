## 冒泡排序
遍历数组将最大元素依次交换，直至数组末尾

 1. 遍历第一次后最大元素会排在数组最后，下次遍历时可不再比较最后一位，所以遍历长度可以逐次减1
 2. 遍历数组如果未发生元素交换，则表示排序完成

时间复杂度：O(n^2)
空间复杂度：O(1)
## 选择排序
从第一位开始，然后遍历数组找出最小值与第一位交换位置，直至倒数第二位

 1. 外层循环至数组倒数第二位即可（length - 1）
 2. 内层循环从当前位置的下一位开始（i + 1）

时间复杂度：O(n^2)
空间复杂度：O(1)
## 插入排序
假设数组前部分是有序的，只需将后部分的无序元素依次插入到有序部分即可

 1. 将数组第一个元素视为有序，外层循环从 i = 1 开始遍历无序部分
 2. 内层循环从 j = i - 1 开始从后往前遍历有序部分，将无序元素依次与有序部分比较并交换值，直至移动到正确位置
 3. 排序过程会改变 arr[i] 的值，需要将 arr[i] 的值存放到一个中间变量 t

---

    // 升序
    if(arr[j] > t) {
      arr[j + 1] = arr[j];
      arr[j] = t;
    }

时间复杂度：O(n^2)
空间复杂度：O(1)
## 归并排序
从第一位开始，然后遍历数组找出最小值与第一位交换位置，直至倒数第二位

 1. 外层循环至数组倒数第二位即可（length - 1）
 2. 内层循环从当前位置的下一位开始（i + 1）

时间复杂度：O(n^2)
空间复杂度：O(1)
## 快速排序
从第一位开始，然后遍历数组找出最小值与第一位交换位置，直至倒数第二位

 1. 外层循环至数组倒数第二位即可（length - 1）
 2. 内层循环从当前位置的下一位开始（i + 1）

时间复杂度：O(n^2)
空间复杂度：O(1)
