## Blog

 - https://zhuanlan.zhihu.com/p/91582909
 - https://zhuanlan.zhihu.com/p/140742301

## 步骤

 1. 定义数组元素的含义
 2. 找出数组元素之间的关系式
 3. 找出初始值
 4. 确定边界情况
 5. 确定计算顺序

## 棋盘路径问题（1）

    var uniquePaths = function(m, n) {
      // 递归，数字过大会爆栈
      // if(m == 1 && n == 1) {
      //   return 1;
      // } else if(m < 1 || n < 1) {
      //   return 0;
      // }
      // else {
      //   return (uniquePaths(m - 1, n) + uniquePaths(m, n - 1));
      // }
    
      // 动态规划
      // 格子可用二维数组来标识，所以终点为(m-1, n-1)
      // 因为只能向前或向下，所以(0, n)和(m, 0)这些格子的路径方式都为1，所以初始化数组时值为1，而遍历数组从(1, 1)开始
      // 要达到(m, n)，只有(m-1, n)和(m, n-1)两种路径，其他格子同理
      // 所以只要把所有格子的值求出来，然后返回终点的值即可
      let dp = new Array(m).fill(1).map(() => new Array(n).fill(1));
      for(let i = 1; i < m; i++) {
        for(let j = 1; j < n; j++) {
          dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
      }
      return dp[m - 1][n - 1];
    };

## 棋盘路径问题（2）

    var uniquePathsWithObstacles = function(obstacleGrid) {
      // 起点有障碍，直接返回0
      if(obstacleGrid[0][0] == 1) return 0;
      // 将所有格子重新赋值为1，障碍为0（方便最后计算）
      for(let i = 0; i < obstacleGrid.length; i++) {
        for(let j = 0; j < obstacleGrid[0].length; j++) {
          if(obstacleGrid[i][j] == 1) obstacleGrid[i][j] = 0; 
          else obstacleGrid[i][j] = 1;
        }
      }
      // 将边界有障碍及之后的格子值设为0
      for(let i = 0; i < obstacleGrid.length; i++) {
        if(obstacleGrid[i][0] == 0) {
            for(let j = i; j < obstacleGrid.length; j++) obstacleGrid[j][0] = 0;
        }
      }
      for(let i = 0; i < obstacleGrid[0].length; i++) {
        if(obstacleGrid[0][i] == 0) {
            for(let j = i; j < obstacleGrid[0].length; j++) obstacleGrid[0][j] = 0;
        }
      }
      // 当终点有障碍，则其值为0；否则为[i-1][j]+[i][j-1]
      for(let i = 1; i < obstacleGrid.length; i++) {
        for(let j = 1; j < obstacleGrid[0].length; j++) {
          if(obstacleGrid[i][j] == 0) obstacleGrid[i][j] = 0;
          else obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
        }
      }
      return obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1];
    };
